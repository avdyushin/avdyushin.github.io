---
layout: post
title: "Regular expressions"
date: "2022-07-06 16:57:52 +0200"
tags: [Regex expressions, Kotlin]
math: true
---

Imagine we need to find some exact _string_ in plain text document, this is straightforward as we know what string to look for.
What if search pattern represented by set of strings, for example all possible binary values `0, 1, 01, 10, 11, 010, ...`?
At first look it's no easy to perform such kind of search, but what if we can generate this set of possible values?

The search string can contain `0` or `1` one or more times.

Having some text, we want to find all strings which represent binary values:

```
12 = 00001100 (In Binary)
25 = 00011001 (In Binary)

Bit Operation of 12 and 25
  00001100
& 00011001
  ________
  00001000  = 8 (In decimal)
```

A _regular expression_ (often called a pattern) is a notation that specifies a set of strings.
Where the main features are: concatenation, alternation, iteration and grouping.

Constants (defined as regular expressions as well):

- $$\emptyset$$ — empty set
- $$\varepsilon$$ — empty string
- $$t$$ — singleton (just a string containing of $$t$$)

Operations over arbitrary regular expressions $$r$$ and $$s$$:

- $$rs$$ — concatenation, any string generated by $$r$$ and by $$s$$
- $$r\vert s$$ — alternation, any string generated by $$r$$ either by $$s$$ 
- $$r*$$ — iteration, zero or more strings generated by $$r$$
- $$(r)$$ — grouping, any string generated by $$r$$ [^1]

[^1]: We can add pairs of parentheses around expressions without changing the set they denote

An regular expressions generates set of strings. Which is simple language called _regular language_ [^2].

[^2]: [Regular language](https://en.wikipedia.org/wiki/Regular_language)

Examples:

| expression                 | generates                              |
| ----------                 | ---------                              |
| $$abc$$                    | $$\{abc\}$$                            |
| $$0\vert 1\vert 2\vert 3$$ | $$\{0, 1, 2, 3\}$$                     |
| $$a*$$                     | $$\{\varepsilon, a, aa, aaa, \dots\}$$ |
| $$abc*$$                   | $$\{ab, abc, abcc, \dots\}$$           |
| $$a(b\vert c)*$$           | $$\{a, ab, ac, abb, acb, \dots\}$$     |

Having this minimum we can combine then, for example:

- One or more string generated by $$r$$ can be expressed by: $$rr*$$
- Optional (one or empty string) generated by $$r$$ can be expressed by: $$(r\vert \varepsilon)$$

### Factorization

Let's say we have regular expression like this:

$$
rs | rt
$$

We can replace it with:

$$
r(s\vert t)
$$

As they both generate exactly the same strings.
