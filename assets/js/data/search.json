[ { "title": "Building custom mechanical keyboard", "url": "/posts/franky36/", "categories": "", "tags": "keyboards", "date": "2025-03-24 19:55:04 +0100", "snippet": "I’ve built a custom mechanical keyboard using a split design with a single controller.Design processSplit keyboard with a single controller, making it easier to set up compared to splits with two controllers connected via a TRRS cable.This design simplifies the wiring and reduces the number of components needed, streamlining the assembly process.CaseThe case was designed using OpenSCAD and 3D printed.Writing code for the 3D models was also fun.It’s like programming but for 3D objects.The 3D printing process enabled rapid prototyping and iteration, allowing for adjustments and improvements to be made quickly.I went through three iterations of the case design, each time refining the layout and making adjustments based on testing.WiringFor the matrix wiring I followed this article: Handwired Keyboard Build Log.The assembly process was straightforward, with the most time-consuming part being the soldering of the diodes and switches.Soldering controller and OLED display was easy part of the assembly.Initial version was based on Pro Micro controller, but during testing and debugging micro USB connector was damaged.And I didn’t manage to solder it back.So it was replaced with a Raspberry Pi 2040 Zero controller.FirmwareI used QMK firmware to program the keyboard.Files structure:keyboards/handwired/franky36/├── config.h├── franky36.c├── halconf.h├── keyboard.json├── keymaps│ └── default│ └── keymap.c└── mcuconf.hFor the new keyboard it’s needed to create a keyboard JSON, that describes the keyboard layout, controller type, matrix pins and features.{ \"keyboard_name\": \"franky36\", [...] \"features\": { \"oled\": true, [...] }, [...] \"matrix_pins\": { \"cols\": [\"GP9\", \"GP10\", \"GP11\", \"GP12\", \"GP13\", \"GP14\", \"GP15\", \"GP26\", \"GP27\", \"GP28\"], \"rows\": [\"GP5\", \"GP4\", \"GP3\", \"GP2\"] }, \"processor\": \"RP2040\", [...]}Next step is to enable I2C for the OLED display.#pragma once#define HAL_USE_I2C TRUE#include_next &lt;halconf.h&gt;Enable I2C in the MCU configuration.#pragma once#include_next &lt;mcuconf.h&gt;#undef RP_I2C_USE_I2C0#define RP_I2C_USE_I2C0 TRUE#undef RP_I2C_USE_I2C1#define RP_I2C_USE_I2C1 FALSESet the I2C pins in the keyboard configuration.#pragma once#define I2C_DRIVER I2CD0#define I2C1_SDA_PIN GP0#define I2C1_SCL_PIN GP1Write some code to show layers and modifiers states on the OLED display.#include QMK_KEYBOARD_H#ifdef OLED_ENABLEstatic void render_logo(void) { static const char PROGMEM qmk_logo[] = { 0x80, 0x81, 0x82, 0x83, 0x84, 0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0x00, 0x0A, 0x0A }; oled_write_P(qmk_logo, false);}static void render_mod_status(uint8_t modifiers) { oled_write_P(PSTR(\"MODS:\"), false); oled_write_P(PSTR(\"S\"), (modifiers &amp; MOD_MASK_SHIFT)); oled_write_P(PSTR(\"C\"), (modifiers &amp; MOD_MASK_CTRL)); oled_write_P(PSTR(\"A\"), (modifiers &amp; MOD_MASK_ALT)); oled_write_ln_P(PSTR(\"G\"), (modifiers &amp; MOD_MASK_GUI)); oled_write_ln_P(PSTR(\" \"), false);}static void render_layer_state(void) { oled_write_ln_P(PSTR(\" \"), false); oled_write_P(\"BASE \", layer_state_is(0)); oled_write_P(\"LOWER\", layer_state_is(1)); oled_write_P(\"RAISE\", layer_state_is(2)); oled_write_P(\"NAV \", layer_state_is(3)); oled_write_ln_P(PSTR(\" \"), false);}static void render_capsword_state(bool on) { oled_write_ln_P(\"CAPSW\", on);}oled_rotation_t oled_init_kb(oled_rotation_t rotation) { return OLED_ROTATION_270;}bool oled_task_kb(void) { if (!oled_task_user()) { return false; } render_logo(); render_layer_state(); render_mod_status(get_mods() | get_oneshot_mods()); render_capsword_state(is_caps_word_on()); return false;}#endifAnd add default keymap.#include QMK_KEYBOARD_Henum my_layers { _BASE = 0, _LOWER, _RAISE, _NAV,};#define LOWER MO(_LOWER)#define RAISE MO(_RAISE)#define NAV MO(_NAV)#define OSM_LSFT OSM(MOD_LSFT) // One Shot Right Shift#define KC_SFT_Z SFT_T(KC_Z) // Left Shift when held, Z when tapped#define KC_SFT_SL RSFT_T(KC_SLSH) // Right Shift when held, / when tapped#define KC_SFT_BSLS RSFT_T(KC_BSLS) // Right Shift when held, \\ when tapped#define KC_LWR_SPC LT(_LOWER, KC_SPC) // Lower layer when held, Space when tapped#define KC_RSE_BSPC LT(_RAISE, KC_BSPC) // Raise layer when held, Backspace when tapped#define KC_NAV_A LT(_NAV,KC_A) // Navigation layer when held, A when tapped#define KC_CMD_TAB CMD_T(KC_TAB) // Left Command when held, Tab when tapped#define KC_CMD_ENT RCMD_T(KC_ENT) // Right Command when held, Enter when tapped#define KC_CTL_ESC CTL_T(KC_ESC) // Left Control when held, Escape when tapped#define KC_OPT_OSM_SFT ROPT_T(OSM_LSFT) // Right Option when held, One Shot Shift when tappedconst uint16_t PROGMEM keymaps[][MATRIX_ROWS][MATRIX_COLS] = {waffle87 marked this conversation as resolved. /* * ┌───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┬───┐ * │ Q │ W │ E │ R │ T │ │ Y │ U │ I │ O │ P │ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ A │ S │ D │ F │ G │ │ H │ J │ K │ L │ ;:│ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │⇧/Z│ X │ C │ V │ B │ │ N │ M │ ,&lt;│ .&gt;│⇧/?│ * └───┴───┴───┴───┴───┘ └───┴───┴───┴───┴───┘ * ┌───┬───┬───┐ ┌───┬───┬───┐ * │CTL│CMD│SPC│ │ENT│CMD│OPT│ * └───┴───┴───┘ └───┴───┴───┘ */ [_BASE] = LAYOUT_split_3x5_3( KC_Q, KC_W, KC_E, KC_R, KC_T, KC_Y, KC_U, KC_I, KC_O, KC_P, KC_NAV_A, KC_S, KC_D, KC_F, KC_G, KC_H, KC_J, KC_K, KC_L, KC_SCLN, KC_SFT_Z, KC_X, KC_C, KC_V, KC_B, KC_N, KC_M, KC_COMM, KC_DOT, KC_SFT_SL, KC_CTL_ESC, KC_CMD_TAB, KC_LWR_SPC, KC_RSE_BSPC, KC_CMD_ENT, KC_ROPT ), /* * ┌───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┬───┐ * │ 1!│ 2@│ 3#│ 4$│ 5%│ │ 6^│ 7&amp;│ 8*│ 9(│ 0)│ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ `~│ │ │ │ │ │ ← │ ↓ │ ↑ │ → │ '\"│ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ ⇧ │ │ │ │ │ │ -_│ =+│ [{│ ]}│ \\|│ * └───┴───┴───┴───┴───┘ └───┴───┴───┴───┴───┘ * ┌───┬───┬───┐ ┌───┬───┬───┐ * │ │ │ │ │ │ │ │ * └───┴───┴───┘ └───┴───┴───┘ */ [_LOWER] = LAYOUT_split_3x5_3( KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7, KC_8, KC_9, KC_0, KC_GRV, _______, _______, _______, _______, KC_LEFT, KC_DOWN, KC_UP, KC_RIGHT, KC_QUOT, KC_LSFT, _______, _______, _______, _______, KC_MINS, KC_EQL, KC_LBRC, KC_RBRC, KC_SFT_BSLS, _______, _______, _______, _______, _______, _______ ), /* * ┌───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┬───┐ * │ F1│ F2│ F3│ F4│ F5│ │ F6│ F7│ F8│ F9│F10│ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ │ │ │ │ │ │ │ │ │ │ │ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ │ │ │ │ │ │ │ │ │ │ │ * └───┴───┴───┴───┴───┘ └───┴───┴───┴───┴───┘ * ┌───┬───┬───┐ ┌───┬───┬───┐ * │ │ │ │ │ │ │ │ * └───┴───┴───┘ └───┴───┴───┘ */ [_RAISE] = LAYOUT_split_3x5_3( KC_F1, KC_F2, KC_F3, KC_F4, KC_F5, KC_F6, KC_F7, KC_F8, KC_F9, KC_F10, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______, _______ ), /* * ┌───┬───┬───┬───┬───┐ ┌───┬───┬───┬───┬───┐ * │ │ │ │ │ │ │HOM│ │ │END│ │ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ │ │ │ │ │ │ ← │ ↓ │ ↑ │ → │ │ * ├───┼───┼───┼───┼───┤ ├───┼───┼───┼───┼───┤ * │ │ │ │ │ │ │PUP│ │ │PDN│ │ * └───┴───┴───┴───┴───┘ └───┴───┴───┴───┴───┘ * ┌───┬───┬───┐ ┌───┬───┬───┐ * │ │ │ │ │ │ │ │ * └───┴───┴───┘ └───┴───┴───┘ */ [_NAV] = LAYOUT_split_3x5_3( _______, _______, _______, _______, _______, KC_HOME, _______, _______, KC_END, _______, _______, _______, _______, _______, _______, KC_LEFT, KC_DOWN, KC_UP, KC_RIGHT, _______, _______, _______, _______, _______, _______, KC_PGUP, _______, _______, KC_PGDN, _______, _______, _______, _______, _______, _______, _______ )};As a bonus point I’ve created PR into QMK repository to add my keyboard.That was approved and officially added to the QMK firmware.Layout designI had troubles to use Planck default layout, so I decided to create my own layout.Still work in progress, very often I’m pressing backspace instead of space.Maybe I should swap them.Links franky36 QMK QMK Configurator" }, { "title": "Building a Clipboard Manager with SwiftUI for macOS", "url": "/posts/clipminder/", "categories": "", "tags": "macos, swiftui", "date": "2025-02-25 19:55:04 +0100", "snippet": "In this post, I will show you how to build a simple clipboard manager for macOS using SwiftUI.The app will display a list of the last items copied to the clipboard and allow you to copy them back to the clipboard.IntroductionI already have an app developed back in 2019 that does this, but it uses AppKit and I wanted to try building it with SwiftUI.This time it will not be published on the App Store, but I will share the code on GitHub.Having say that, I hope you enjoy this post and find it useful.Please note, this is not a tutorial for beginners, but some findings I had while developing this app. Mostly for my future self.Status Bar itemThe app will be a status bar item, so we need to create a new MenuBarExtra view and set menu view inside it.MenuBarExtra(\"ClipMinder\", systemImage: \"paperclip\") { AppMenu()}.menuBarExtraStyle(.menu)As app runs in the background, we need to add a new key to the Info properties under the app’s target to hide the dock icon: Application is agent (UIElement) to YES.SettingsShow app settings is super easy using SwiftUI.Just create a new view and place it inside a Settings view:Settings { SettingsView()}The ClipboardTo access the system clipboard, we need to use the NSPasteboard class.It has string(forType:) and setString(_:forType:) methods to get and set the clipboard content.Also it has a changeCount property to check if the clipboard content has changed.Collecting pasteboard items using timer:@Observablefinal class PasteboardServiceImpl { private let pasteboard: NSPasteboard private var timer: AnyCancellable? private var changeCount = -1 var currentItem: String? = nil init(polling: TimeInterval = 5, pasteboard: NSPasteboard = .general) { self.pasteboard = pasteboard changeCount = pasteboard.changeCount if let string = pasteboard.string(forType: .string) { currentItem = string } timer = Timer.publish(every: polling, on: .current, in: .default) .autoconnect() .compactMap { [weak self] _ in guard pasteboard.changeCount != self?.changeCount else { return nil } guard pasteboard.availableType(from: [.string]) == .string else { return nil } guard let string = pasteboard.string(forType: .string) else { return nil } self?.changeCount = pasteboard.changeCount return string } .receive(on: DispatchQueue.main) .sink { [weak self] item in self?.currentItem = item } } deinit { timer?.cancel() }Copying string back to the system clipboard:pasteboard.declareTypes([.string], owner: self)pasteboard.setString(string, forType: .string)Launch at loginTo register app to launch at login, we need to use the ServiceManagement framework. It has a SMAppService.mainApp object to register and unregister the app.final class AppLaunchServiceImpl: AppLaunchService { private var status: SMAppService.Status { SMAppService.mainApp.status } var launchAtLogin: Bool { status == .enabled } func toggleLaunchAtLogin(isLaunchAtLogin: Bool) { if isLaunchAtLogin { try? SMAppService.mainApp.register() } else { try? SMAppService.mainApp.unregister() } }}Listen for local keystrokesTo listen for local keystrokes, we need to use the NSEvent class. It has a addLocalMonitorForEvents(matching:handler:) method to listen for local events.We are interested in the .keyDown and .flagsChanged events only.@Observablefinal class LocalKeyListener { var hotKeyEvent = NSEvent() var isActive = false init() { NSEvent.addLocalMonitorForEvents(matching: [.keyDown]) { [weak self] event in guard let self else { return event } if isActive &amp;&amp; !event.modifierFlags.toEventModifiers().isEmpty { hotKeyEvent = event isActive = false } return event } NSEvent.addLocalMonitorForEvents(matching: [.flagsChanged]) { [weak self] event in guard let self else { return event } if event.modifierFlags.toEventModifiers().isEmpty { isActive = true } return event } }}Listen for global keystrokesTo listen for global keystrokes, we need to use the CGEvent class. It has a tapCreate(tap:place:options:eventsOfInterest:callback:userInfo:) method to listen for global events.@Observablefinal class GlobalKeyListener { private var eventTap: CFMachPort? var hotKeyTriggered = false init() { let callback: CGEventTapCallBack = { (proxy, type, event, info) -&gt; Unmanaged&lt;CGEvent&gt;? in guard let rawValue = UserDefaults.standard.string(forKey: \"hot_key\") else { debugPrint(\"No hot key is defined, check settings!\") return .passUnretained(event) } let hotKey = HotKey(rawValue: rawValue) let keyCode = event.getIntegerValueField(.keyboardEventKeycode) let modifiers = event.flags.toEventModifiers() if keyCode == hotKey.keyCode, modifiers == hotKey.modifiers { if let info { Unmanaged&lt;GlobalKeyListener&gt;.fromOpaque(info).takeUnretainedValue().hotKeyTriggered = true return nil } } return .passUnretained(event) } let userInfo = Unmanaged.passRetained(self).toOpaque() eventTap = CGEvent.tapCreate( tap: .cgSessionEventTap, place: .headInsertEventTap, options: .listenOnly, eventsOfInterest: (CGEventMask(1 &lt;&lt; CGEventType.keyDown.rawValue)), callback: callback, userInfo: userInfo ) guard let eventTap else { Unmanaged&lt;GlobalKeyListener&gt;.fromOpaque(userInfo).release() debugPrint(\"Can't create &lt;CGEvent.tapCreate&gt;!\") return } let runLoop = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventTap, 0) CFRunLoopAddSource(CFRunLoopGetCurrent(), runLoop, .defaultMode) } deinit { Unmanaged.passUnretained(self).release() }}ConclusionLaunch app at login and keep it in status bar is a good way to have a clipboard manager always available.Listening for global keystrokes is a good way to trigger the app without using the mouse.Source codeFull source code can be found at GitHub repo ClipMinder." }, { "title": "Setup RetroArch on Raspberry Pi", "url": "/posts/raspberry-pi-retroarch/", "categories": "", "tags": "retro, raspberry pi", "date": "2021-04-06 20:55:04 +0200", "snippet": "Requirements: Raspberry Pi 4 SD card with Raspbian Another Linux (virtual) desktop to use GPartedOnce raspbian image installed it’s good to shrink root partition and extract another one for storage.The goal is to have Raspbian with Desktop and option to boot into RetroArch without using Lakka.This will give full control over OS like using custom services and applications.Change raspbian boot order to boot into CLI mode, we will add startup screen later.WiFiInstall and configure connman:$ sudo apt install connmanClean old wifi connections (if needed or scan wifi doesn’t work):$ sudo mv /etc/wpa_supplicant/wpa_supplicant.conf /etc/wpa_supplicant/wpa_supplicant.conf.orig$ sudo rebootSetup connman:$ connmanctlconnmanctl&gt; enable wificonnmanctl&gt; scan wificonnmanctl&gt; servicesWIFI_NAME wifi_XXXXXX_XXX_managed_pskconnmanctl&gt; agent onconnmanctl&gt; connect wifi_XXXXXX_XXX_managed_pskconnmanctl&gt; servicesconnmanctl&gt; quit$ ifconfigStatic IP (Optional)Edit wifi settings at /var/lib/connman/wifi_XXXXXX_XXX_managed_psk/settings[wifi_XXXXXX_XXX_managed_psk]Name=XXXXXXXXXXSSID=XXXXXXXXXXXXXXXXXXXXFavorite=trueAutoConnect=truePassphrase=XXXXXXXXFrequency=2437Modified=2020-07-04T15:47:43.045286ZIPv4.method=manualIPv4.netmask_prefixlen=24IPv4.local_address=192.168.0.113IPv4.gateway=192.168.0.1IPv6.method=offIPv6.privacy=disabledRetroArchGet sources:$ curl -LO 'https://github.com/libretro/RetroArch/archive/v1.9.0.tar.gz'$ tar -zxvf v1.9.0.tar.gz$ cd RetroArch-1.9.0/Install dependencies:$ sudo apt install build-essential git libasound2-dev libavcodec-dev libavdevice-dev libavformat-dev libavresample-dev libdrm-common libdrm-dev libdrm2 libegl1-mesa-dev libfreetype6-dev libgbm-dev libgbm-dev libgbm1 libgles2 libgles2-mesa libgles2-mesa-dev libsdl-image1.2-dev libsdl2-dev libswresample-dev libswscale-dev libudev-dev libv4l-dev libxkbcommon-dev libxml2-dev yasm zlib1g-devConfigure:$ CFLAGS='-march=armv8-a+crc+simd -mcpu=cortex-a72 -mtune=cortex-a72 -mfloat-abi=hard -mfpu=neon-fp-armv8' CXXFLAGS=\"${CFLAGS}\" ./configure --disable-caca --disable-jack --disable-opengl1 --disable-oss --disable-sdl --disable-sdl2 --disable-videocore --disable-vulkan --disable-wayland --disable-x11 --enable-alsa --enable-egl --enable-floathard --enable-kms --enable-neon --enable-opengles --enable-opengles3 --enable-pulse --enable-udevBuild with lakka support:$ make V=1 HAVE_LAKKA=1 HAVE_BLUETOOTH=1 HAVE_NETWORKING=1 -j4This will enable Shutdown menu option, Wi-Fi and Bluetooth options.$ sudo apt install checkinstall$ sudo checkinstall --pkgname=retroarch-rpi4 --conflicts=retroarch --pkgversion=1.9.0 --install=no$ sudo dpkg -i retroarch-rpi4_1.9.0-1_armhf.debRun RetroArch to have configuration file to be created.Set core_updater_buildbot_cores_url inside.config/retroarch/retroarch.cfg:core_updater_buildbot_cores_url = \"http://buildbot.libretro.com/nightly/linux/armv7-neon-hf/latest/\"Update Drivers:Video -&gt; glcoreBluetooth -&gt; bluetoothctlWi-Fi -&gt; connmanctlUpdate assets with online updater and restart retroarch.PSP Emulator$ git clone https://github.com/hrydgard/ppsspp$ cd ppsspp &amp;&amp; git submodule update --init --recursive$ CMAKE_ARGS='-DUSING_X11_VULKAN=OFF -DUSE_SYSTEM_FFMPEG=ON' ./b.sh --rpi --libretroAnd copy core into retroarch:$ cp build/lib/ppsspp_libretro.so ~/.config/retroarch/cores/NOTES: PPSSPP works only with gl (and not glcore) video driver.Bluetooth Controller$ systemctl status bluetooth$ sudo rfkill unblock bluetooth # if blocked$ bluetoothctl[bluetoothctl]# agent on[bluetoothctl]# default-agent[bluetoothctl]# power on[bluetoothctl]# discoverable on[bluetoothctl]# pairable on[bluetoothctl]# scan on[bluetoothctl]# connect &lt;device_address&gt;[device_address]# trust &lt;device_address&gt;Shutdown buttonAttach button to pin 9 (GND) and pin 11 (GPIO17) on raspberry board and add to /boot/config.txt:dtoverlay=gpio-shutdown,gpio_pin=17Now when you press the button raspberry will shutdown.Links https://www.reddit.com/r/RetroArch/comments/l158qt/best_performing_retroarch_build_on_a_raspberry_pi/ https://github.com/hrydgard/ppsspp https://pinout.xyz/pinout/" }, { "title": "Setup Lakka on Raspberry Pi", "url": "/posts/raspberry-pi-lakka/", "categories": "", "tags": "retro, raspberry pi", "date": "2020-07-04 10:04:46 +0200", "snippet": "Lakka configuration Connect Ethernet cable or connect to WiFi from GUI. Turn on SSH in ServicesStatic IPConnect via ssh:ssh root@lakka.localEdit WiFi settings:$ vi /storage/.cache/connman/wifi_XXXXXX_managed_psk/settingsChange IP method to manual and set local_address:[wifi_XXXXXX_managed_psk]Name=XXXXXXXXXXSSID=XXXXXXXXXXXXXXXXXXXXFavorite=trueAutoConnect=truePassphrase=XXXXXXXXFrequency=2437Modified=2020-07-04T15:47:43.045286ZIPv4.method=manualIPv4.netmask_prefixlen=24IPv4.local_address=192.168.0.113IPv4.gateway=192.168.0.1IPv6.method=offIPv6.privacy=disabledRestart WiFi:$ connmanctl disable wifi$ connmanctl enable wifi$ connmanctl connect wifi_XXXXXX_managed_pskThe same for the wired connection (you have to connect cable first to see this config):$ vi /storage/.cache/connman/ethernet_XXXXXX_cable/settingsOn local machine for easy access can be added: ~/.ssh/config:Host lakka.wlan UserKnownHostsFile ~/.ssh/known_hosts.wlan.lakka Hostname 192.168.0.113Host lakka.eth UserKnownHostsFile ~/.ssh/known_hosts.eth.lakka Hostname 192.168.0.111Then to connect to ssh via WiFi:$ ssh root@lakka.wlanSet timezoneecho \"TIMEZONE=Europe/Amsterdam\" &gt; /storage/.cache/timezoneFix HDMI AudioTo edit config.txt remount /flash with write access:mount /flash -o remount,rwvi /flash/config.txtAdd new lines into configuration file:# Normal HDMI mode with soundhdmi_drive=2hdmi_force_edid_audio=1Use closest to power HDMI port.Bluetooth controllerDisable bluetooth ertm to have Xbox one controller paired with bluetooth.Create file /etc/modprobe.d/bluetooth.conf with content:options bluetooth disable\\_ertm=YVerify if it’s work after reboot:cat /sys/module/bluetooth/parameters/disable_ertmYWhere Y is disabled and N enabled.Pair using bluetoothctl.Copy BIOSes/ROMsscp BIOS/* root@lakka.eth:system/Add missing box-arts as PNG files only.Links https://www.lakka.tv https://www.lakka.tv/doc/8Bitdo-Wireless-Controller/ https://www.reddit.com/r/RetroPie/comments/aakkop/xbox_one_s_controller_disable_ertm_persist_on/" }, { "title": "Setup EDuke32 on macOS", "url": "/posts/eduke32-macos/", "categories": "", "tags": "retro, macos", "date": "2020-07-01 13:36:37 +0200", "snippet": "EDuke32 ConfigurationCheck list to run EDuke32 on macOS with HRP (High Resolution Pack): Get EDuke32 and launch for the first time to generate default config files Check logs here: ~/Library/Logs/eduke32.log Configuration path: ~/.config/eduke32/ Edit eduke32.cfg to set NoAutoLoad = 0 Get HRP and put zip files into: ~/.config/eduke32/autoload/ Display Setup -&gt; Video Mode -&gt; Renderer -&gt; Polymer Display Setup -&gt; Polymer Setup -&gt; Turn on stuff duke3d_hrp.zip should be original downloaded file and not unpacked and compressed againLevels DataOnce you own Duke Nukem you have to put game data into ~/.config/eduke32In order to download owned Duke Nukem 3D: 20th Anniversary World Tour from Steam app on macOS:Create new file ~/Library/Application Support/Steam/steamapps/appmanifest_434050.acf:\"AppState\"{ \"appid\" \"434050\" \"Universe\" \"1\" \"name\" \"Duke Nukem 3D: 20th Anniversary World Tour\" \"StateFlags\" \"1026\" \"installdir\" \"Duke Nukem 3D\"}Launch Steam app and download game.Copy DUKE.RTS and DUKE3D.GRP from ~/Library/Application Support/Steam/steamapps/common/Duke Nukem 3D/ into ~/.config/eduke32/.Links EDuke32 Hi-Res pack Steam AppManifest" }, { "title": "Swift keypaths", "url": "/posts/swift-keypaths/", "categories": "", "tags": "swift", "date": "2020-06-23 11:10:41 +0200", "snippet": "Extending Sequence to have method that calculates sum:extension Sequence where Element: AdditiveArithmetic { func sum() -&gt; Element { reduce(.zero, +) }}This sum() available for any sequence with values that confirms AdditiveArithmetic protocol.Consider we have custom struct like and array of this objects:struct LocationData { let speed: Double}let data = [10, 11, 14, 15, 19].map(LocationData.init)To calculate average speed we find sum and divide by count:let avgSpeed = data.map { $0.speed }.sum() / Double(data.count)// avgSpeed = 13.8Using keypath we can reference to properties:let speedKeyPath = \\LocationData.speedLet’s extend sequence to have method that calculates sum of given keypath element:extension Sequence { func sum&lt;T: AdditiveArithmetic&gt;(by keyPath: KeyPath&lt;Element, T&gt;) -&gt; T { map { $0[keyPath: keyPath] }.sum() }}Now average speed calculation can be expressed shorter:let avgSpeed = data.sum(by: \\.speed) / Double(data.count)// avgSpeed = 13.8" }, { "title": "Cycling power calculation", "url": "/posts/cycling-power/", "categories": "", "tags": "", "date": "2020-06-21 20:00:24 +0200", "snippet": "The physics behind cyclingTo move forward with constant speed \\(V\\) you have to provide energy (power) to overcome total resistive force:\\[P = F_r \\cdot V = ( F_{downhill} + F_{rolling} + F_{drag} ) \\cdot V\\]GravityCycling uphill or downhill force:\\[F_{downhill} = m \\cdot g \\cdot sin(\\theta)\\]where: \\(m\\) - weight of cyclist and bike; \\(g = 9.80665~m/s^2\\) - earth-surface gravitational acceleration.Rolling resistance\\[F_{rolling} = C_{rr} \\cdot m \\cdot g \\cdot cos(\\theta)\\]where: \\(C_{rr}\\) - coefficient of rolling resistance.The coefficient of rolling resistance of the air filled tires on dry road:\\[C_{rr} = 0.005 + \\frac 1 p \\left( 0.01 + 0.0095 \\left(\\frac V {100}\\right)^2 \\right)\\]where: \\(p\\) - the wheel pressure (Bar); \\(V\\) - the velocity (km/h).The angle \\(\\theta\\) can be calculated using elevation gain and total distance:\\[tan(\\theta) = \\frac H L \\Rightarrow \\theta = arctan\\left(\\frac H L\\right)\\]where: \\(H\\) - height (opposite side); \\(L\\) - length (adjacent side).Aerodynamic DragDrag force:\\[F_{drag} = \\frac 1 2 \\cdot \\rho \\cdot (V - V_w)^2 \\cdot C_d \\cdot A\\]where: \\(\\rho\\) - the density of the air; \\(V\\) - the speed of the bike; \\(V_W\\) - the speed of the wind; \\(A\\) - the projected frontal area of the cyclist and bike; \\(C_d\\) - the drag coefficient.Approximated body surface area can be estimated from the measurement of the body height and body mass(Du Bois &amp; Du Bois, 1916; Shuter &amp; Aslani, 2000):\\[A = 0.00949 \\cdot (H/100)^{0.655} \\cdot m^{0.441}\\]where: \\(H\\) - the body height in \\(m\\); \\(m\\) - the body mass in \\(kg\\).Drag coefficient in cycling can be related to the body mass also and depends on cyclist position.DensityThe density of the air is its mass per unit volume:\\[\\rho = \\frac m V\\]where: \\(m\\) - the mass; \\(V\\) - the volume.It decreases with increasing altitude and changes with variation in temperature or humidity.The density of dry air:\\[\\rho = \\frac {p_0 M} {R T_0} \\left(1 - \\frac {Lh}{T_0}\\right)^{gM/RL-1}\\]where air specific constants: \\(p_0 = 101325~Pa\\) - sea level standard pressure; \\(T_0 = 288.15~K\\) - sea level standard temperature; \\(M = 0.0289654~kg/mol\\) - molar mass of dry air; \\(R = 8.31447~J/(mol \\cdot K)\\) - ideal gas constant; \\(g = 9.80665~m/s^2\\) - earth-surface gravitational acceleration; \\(L = 0.0065~K/m\\) - temperature lapse rate.Density close to the ground is:\\[\\rho_0 = \\frac {p_0 M} {R T_0}\\]At sea level and at 15℃, air has \\(1.225~kg/m^3\\).Using exponential approximation:\\[\\rho = \\rho_0 e^{(\\frac {gM}{RL} - 1) \\cdot ln(1 - \\frac {Lh}{T_0})} \\approx \\rho_0 e^{-(\\frac {gMh} {R T_0} - \\frac {Lh} {T_0})}\\]Thus:\\[\\rho \\approx \\rho_0 e^{-h / H_n}\\]where:\\[\\frac 1 H_n = \\frac {gM} {R T_0} - \\frac L T_0\\]So \\(H_n = 10.4~km\\).Coefficients TableRolling resistance coefficient: Tire type \\(C_{rr}\\) Bicycle 0.006 Road bike 0.004 Surface area and drag coefficient of cyclist: Position \\(A~m^2\\) \\(C_d\\) \\(C_d A\\) Back Up 0.423 0.655 0.277 Back Horizontal 0.370 0.638 0.236 Back Down 1 0.339 0.655 0.222 Back Down 2 0.334 0.641 0.214 Elbows 0.381 0.677 0.258 Froome 0.344 0.677 0.233 Top Tube 1 0.371 0.644 0.239 Top tube 2 0.355 0.611 0.217 Top Tube 3 0.345 0.588 0.203 Top Tube 4 0.333 0.604 0.201 Pantani 0.343 0.618 0.212 TT* &amp; TT Helmet 0.370 0.641 0.237 TT Top Tube 0.331 0.568 0.188 TT &amp; Helmet 0.374 0.679 0.254 Superman 0.244 0.615 0.150 * Time trialConclusionBased on all this formulas we are able to calculate power effort, burned calories and fat loss of bike ride activity.Links http://bikecalculator.com http://thecraftycanvas.com/library/online-learning-tools/physics-homework-helpers/incline-force-calculator-problem-solver/ https://www.gribble.org/cycling/power_v_speed.html https://www.researchgate.net/publication/51660070_Aerodynamic_drag_in_cycling_Methods_of_assessment https://www.sciencedirect.com/science/article/pii/S0167610518305762" }, { "title": "Using XML and XSLT for code generation", "url": "/posts/xslt-auto-generation/", "categories": "", "tags": "xml, xslt", "date": "2020-06-15 07:59:40 +0200", "snippet": "XML files can be transformed into different one using XSL templates.The result of applying template could be another XML, HTML, text or any document.Input XMLAs an example we will be using XML file contains strings translations:&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;strings&gt; &lt;string id=\"login\"&gt; &lt;en&gt;Log in&lt;/en&gt; &lt;nl&gt;Inloggen&lt;/nl&gt; &lt;ru&gt;Вход&lt;/ru&gt; &lt;/string&gt; &lt;string id=\"sign_in\"&gt; &lt;en&gt;Sign in&lt;/en&gt; &lt;de&gt;Anmelden&lt;/de&gt; &lt;/string&gt;&lt;/strings&gt;Each string node has id attribute contains string identifier.Using this identifier we are going to build swift enum with contains named by identifier.So later in out code we can use autocompletion and prevent typing errors:Expected auto-generated enum:/// Auto-generatedenum Strings { static let login = \"login\" static let sign_in = \"sign_in\"}XSLT Template&lt;!-- enum.xslt --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:fo=\"http://www.w3.org/1999/XSL/Format\"&gt;&lt;xsl:output omit-xml-declaration=\"yes\"/&gt; &lt;!-- 1 --&gt;&lt;xsl:template match=\"/\"&gt; &lt;!-- 2 --&gt;/// Auto-generatedenum Strings {&lt;xsl:for-each select=\"strings/string\"&gt; &lt;!-- 3 --&gt; &lt;xsl:text&gt; static let &lt;/xsl:text&gt; &lt;!-- 4 --&gt; &lt;xsl:value-of select=\"@id\"/&gt; &lt;!-- 5 --&gt; &lt;xsl:text&gt; = \"&lt;/xsl:text&gt; &lt;xsl:value-of select=\"@id\"/&gt; &lt;xsl:text&gt;\"&lt;/xsl:text&gt; &lt;xsl:text&gt;&amp;#xa;&lt;/xsl:text&gt; &lt;!-- 6 --&gt;&lt;/xsl:for-each&gt;}&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; To generate plain text we have to ignore default XML header produced by applying template Main rules to apply to root (/) element Loops through each string node in strings node set Writes liter text to the output Extracts values of the id attribute Writes new line to the outputTransform XML into text file using xsltproc utility:$ xsltproc enum.xslt input.xml &gt; strings.swiftGetting distinct valuesIn order to get a list of all translated languageswe have to iterate over all strings and get distinct nodes only.To do this we can use xsl:key together with generate-id:&lt;!-- list.xslt --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:fo=\"http://www.w3.org/1999/XSL/Format\"&gt; &lt;xsl:output omit-xml-declaration=\"yes\"/&gt; &lt;xsl:key name=\"lang_id\" match=\"/strings/string/node()\" use=\"name(.)\"/&gt; &lt;!-- 1 --&gt; &lt;xsl:template match=\"/\"&gt; &lt;xsl:for-each select=\"strings/string/node()[generate-id() = generate-id(key('lang_id',name(.))[1])]\"&gt; &lt;!-- 2 --&gt; &lt;xsl:value-of select=\"name(.)\"/&gt;&lt;xsl:text&gt;&amp;#xa;&lt;/xsl:text&gt; &lt;/xsl:for-each&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; Top-level element to define named key as node name Override function to return string that uniquely identifies a nodeApplying this template to the input XML will produce a list of unique translated languages:$ xsltproc list.xslt input.xmlennlrudeNext step is to generate Localized.strings file for given language.Input parametersUsing xsl:param we can declare global (or local) parameter.A xsl:variable defines global (or local) variable that will be used as default parameter value:&lt;xsl:variable name=\"defaultLang\"&gt; &lt;xsl:text&gt;en&lt;/xsl:text&gt;&lt;/xsl:variable&gt;&lt;xsl:param name=\"lang\" select=\"$defaultLang\"/&gt;To set parameter from outside we have to pass it as a parameter to xsltproc:$ xsltproc --stringparam lang ru strings.xslt input.xmlTest conditionsUsing xsl:if element we can apply template only if test condition is true. normalize-space() trims leading and trailing spaces, so we can filter out strings contains only whitespaces. name() returns name of the current node text() returns content of the current node&lt;!-- strings.xslt --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:fo=\"http://www.w3.org/1999/XSL/Format\"&gt;&lt;xsl:output omit-xml-declaration=\"yes\"/&gt;&lt;xsl:variable name=\"defaultLang\"&gt; &lt;xsl:text&gt;en&lt;/xsl:text&gt;&lt;/xsl:variable&gt;&lt;xsl:param name=\"lang\" select=\"$defaultLang\"/&gt;&lt;xsl:template match=\"/\"&gt;&lt;xsl:text&gt;/// Auto-generated&lt;/xsl:text&gt;&lt;xsl:text&gt;&amp;#xa;&lt;/xsl:text&gt;&lt;xsl:text&gt;/// Language: &lt;/xsl:text&gt;&lt;xsl:value-of select=\"$lang\"/&gt;&lt;xsl:text&gt;&amp;#xa;&lt;/xsl:text&gt;&lt;xsl:text&gt;&amp;#xa;&lt;/xsl:text&gt;&lt;xsl:for-each select=\"strings/string\"&gt; &lt;!-- 1 --&gt; &lt;xsl:if test=\"normalize-space(./*[name() = $lang]/text()) != ''\"&gt; &lt;!-- 2 --&gt; &lt;xsl:text&gt;\"&lt;/xsl:text&gt; &lt;xsl:value-of select=\"@id\"/&gt; &lt;xsl:text&gt;\" = \"&lt;/xsl:text&gt; &lt;xsl:value-of select=\"./*[name() = $lang]\"/&gt; &lt;!-- 3 --&gt; &lt;xsl:text&gt;\";&lt;/xsl:text&gt; &lt;xsl:text&gt;&amp;#xa;&lt;/xsl:text&gt; &lt;/xsl:if&gt;&lt;/xsl:for-each&gt;&lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; Iterate over strings Check if content of node with name $lang (our external parameter) is not empty Get content of the nodeShell scriptHere is shell script to put all things together:!/bin/shfor lang in $(xsltproc list.xslt strings.xml) # 1do echo \"Processing $lang...\" mkdir -p $lang # 2 xsltproc --stringparam lang $lang strings.xslt strings.xml &gt; $lang/Localizable.strings #3donexsltproc enum.xslt strings.xml &gt; strings.generated.swift #4 Iterate over languages Make directory if needed Generate strings file Generate enum filesValidating XMLTo validate input XML file we can use xmllint:$ xmllint strings.xmlFormatting XMLIn order to sort nodes we can use xsl:sort element:&lt;!-- sort.xslt --&gt;&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/xsl/Transform\"&gt; &lt;xsl:output method=\"xml\" encoding=\"UTF-8\" indent=\"yes\" omit-xml-declaration=\"no\"/&gt; &lt;xsl:strip-space elements=\"*\"/&gt; &lt;!-- 1 --&gt; &lt;xsl:template match=\"@* | node()\"&gt; &lt;xsl:copy&gt; &lt;!-- 2 --&gt; &lt;xsl:apply-templates select=\"@* | node()\"/&gt; &lt;/xsl:copy&gt; &lt;/xsl:template&gt; &lt;xsl:template match=\"string\"&gt; &lt;xsl:copy&gt; &lt;xsl:apply-templates select=\"@*\"/&gt; &lt;xsl:apply-templates select=\"*\"&gt; &lt;xsl:sort select=\"name(.)\" data-type=\"text\" order=\"ascending\"/&gt; &lt;!-- 3 --&gt; &lt;/xsl:apply-templates&gt; &lt;/xsl:copy&gt; &lt;/xsl:template&gt;&lt;/xsl:stylesheet&gt; Remove white spaces for all elements Copy current element without child nodes Sort by node name in ascending orderUsage:$ xsltproc -o formatted.xml sort.xslt input.xmlConclusionUsing XSLT it’s possible to generate new files based on XML input.With different templates and parameters we managed to build simple localization platform.Adding only one more template and step into generation script it could generate translated strings for Android as well.Links Localizable XSLT Elements Reference" }, { "title": "Building Split View in SwiftUI", "url": "/posts/building-splitview-in-swiftui/", "categories": "", "tags": "swift, swiftui", "date": "2020-05-23 13:00:53 +0200", "snippet": "IntroductionSwiftUI in PlaygroundXcode’s Playground templates unfortunately has none of them for SwiftUI.For now we can create a new Blank Playground project and add boilerplate code:import SwiftUIimport PlaygroundSupportstruct SplitView: View { var body: some View { Text(\"Split View\") }}PlaygroundPage.current.setLiveView(SplitView())Playground is ready, so once it run it will display live view preview.Creating new ViewView Composition in SwiftUI:struct SplitView&lt;Content: View&gt;: View { let content: () -&gt; Content var body: some View { content() }}And set live view with new content:PlaygroundPage.current.setLiveView( SplitView { Text(\"Split View\") })Let’s place two views inside VStack:struct SplitView&lt;Content: View&gt;: View { let topContent: () -&gt; Content let bottomContent: () -&gt; Content var body: some View { VStack { topContent() bottomContent() } }}Now we have two view split vertically:PlaygroundPage.current.setLiveView( SplitView( topContent: { Text(\"Top View\") }, bottomContent: { Text(\"Bottom View\") } ))What is we place HStack into bottom view?HStack { Text(\"Bottom Left View\") Text(\"Bottom Right View\")}It will not work because now top and bottom content has different view types: Text and HStack.To fix it we have to use two generic types to build out view:struct SplitView&lt;TopContent: View, BottomContent: View&gt;: View { let topContent: () -&gt; TopContent let bottomContent: () -&gt; BottomContent var body: some View { VStack { topContent() bottomContent() } }}Using @ViewBuilderComplete custom view container using @ViewBuilder:struct SplitView&lt;TopContent: View, BottomContent: View&gt;: View { let topContent: TopContent let bottomContent: BottomContent init(@ViewBuilder _ topContent: () -&gt; TopContent, @ViewBuilder _ bottomContent: () -&gt; BottomContent) { self.topContent = topContent() self.bottomContent = bottomContent() } var body: some View { VStack { topContent bottomContent } }}PlaygroundPage.current.setLiveView( SplitView({ Text(\"Top View\") Text(\"Top Title\") }, { HStack { Text(\"Bottom Left View\") Text(\"Bottom Right View\") } }))SliderControlViewModelTo keep track of slider positions let’s introduce view model:class SliderControlViewModel: ObservableObject { @Published var current: CGFloat = 0 // 1 @Published var previous: CGFloat = 0 // 2} Current relative position of the slider Previous positionGeometryReaderGeometryReader allows us to get size (and coordinates) of views.We could use it to make a view have full width of all available space.var body: some View { GeomertyReader { geometry in Text(\"View\").frame(width: geometry.size.width) }}That geometry parameter also contains safe area insets.DragGestureIn SwiftUI we can attach custom gesture to any view.We will attach DragGesture to slider control viewso that it can moved around.SliderControlViewstruct SliderControl&lt;Content: View&gt;: View { @ObservedObject var viewModel: SliderControlViewModel var geometry: GeometryProxy // 1 let content: Content init( viewModel: SliderControlViewModel, geometry: GeometryProxy, @ViewBuilder content: () -&gt; Content) { self.viewModel = viewModel self.content = content() self.geometry = geometry } var body: some View { VStack { content } .offset(y: geometry.size.height / 2 + viewModel.current) .gesture( DragGesture() // 2 .onChanged(onDragChanged) .onEnded(onDragEnded) ) } fileprivate var maxLimit: CGFloat { geometry.size.height * 0.8 } fileprivate var minLimit: CGFloat { geometry.size.height * 0.2 } fileprivate func onDragChanged(_ gesture: DragGesture.Value) { let height = viewModel.previous + gesture.translation.height viewModel.current = max(maxLimit, min(minLimit, height)) // 3 } fileprivate func onDragEnded(_ gesture: DragGesture.Value) { viewModel.previous = viewModel.current // 4 }} Pass GeometryProxy to get hosting view size Add DragGesture Limit offset into min and max possible values Save previous positionSplitViewAll things together:struct SplitView&lt;ControlView: View, TopContent: View, BottomContent: View&gt;: View { @ObservedObject var viewModel: SliderControlViewModel var controlView: ControlView var topView: TopContent var bottomView: BottomContent init( viewModel: SliderControlViewModel, @ViewBuilder controlView: () -&gt; ControlView, @ViewBuilder topView: () -&gt; TopContent, @ViewBuilder bottomView: () -&gt; BottomContent) { self.viewModel = viewModel self.controlView = controlView() self.topView = topView() self.bottomView = bottomView() } var body: some View { GeometryReader { geometry in ZStack { VStack { Group { self.topView .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity) } Group { self.bottomView .frame(minWidth: 0, maxWidth: .infinity, minHeight: 0, maxHeight: .infinity) .frame(height: geometry.size.height / 2 - self.viewModel.current) } } SliderControl(viewModel: self.viewModel, geometry: geometry) { Group { self.controlView } } } // ZStack } // GeometryReader }}Links Swift Package SplitView" }, { "title": "Building Swift DI using Property Wrappers", "url": "/posts/swift-property-wrappers/", "categories": "", "tags": "swift", "date": "2020-05-14 16:53:45 +0200", "snippet": "Dependency Injection using Swift Property WrappersNote: Code tested using Swift 5.2.2 and Xcode 11.4.1Dependency InjectionDependency Injection (DI) helps us to separate creation and usage of an object.We can replace implementations (in Unit Tests for example) without changing the object that uses dependencies.In example below Service is tightly coupled with ViewModel object:class Service { }class ViewModel { let service: Service init() { self.service = Service() // ViewModel knows how to create Service }}We can use property injection DI, so ViewModel will not create Service by itself:class MockService: Service { }class ViewModel { let service: Service init(service: Service) { self.service = service // Can be any subclass of Service }}Using protocols helps us to hide concrete types, so ViewModel should know only how to use object.Our goal is to use DI with Swift’s property wrapper like this:protocol ServiceProtocol { }class Service: ServiceProtocol { }class MockService: ServiceProtocol { }class ViewModel { @Injected var service: ServiceProtocol init() { service.start() // ViewModel can start using service }}In order to do achieve this we need 3 main components: Dependency resolver; Dependency container; Custom property wrapper.Dependency ResolverDependency resolver is a simple factory.We provide block which returns an object we want to inject into dependency container.struct Dependency { typealias ResolveBlock&lt;T&gt; = () -&gt; T private(set) var value: Any! // Actual value will be assigned after resolve() call private let resolveBlock: ResolveBlock&lt;Any&gt; let name: String init&lt;T&gt;(_ block: @escaping ResolveBlock&lt;T&gt;) { resolveBlock = block // Save block for future name = String(describing: T.self) } mutating func resolve() { value = resolveBlock() }}Actual injection will be performed after resolve() call.let service = Dependency { Service() }service.value // nilservice.resolve()service.value // Service instanceDependency ContainerDependency container will manage added Depenedency objects. Register given Dependency in container; Build resolved dependencies list; Resolve single dependency of given type.class Dependencies { static private(set) var shared = Dependencies() // 1 fileprivate var dependencies = [Dependency]() // 2 func register(_ dependency: Dependency) { // Avoid duplicates guard dependencies.firstIndex(where: { $0.name == dependency.name }) == nil else { debugPrint(\"\\(String(describing: dependency.name)) already registered, ignoring\") return } dependencies.append(dependency) } func build() { // We assuming that at this point all needed dependencies are registered for index in dependencies.startIndex..&lt;dependencies.endIndex { dependencies[index].resolve() } Self.shared = self // 3 } func resolve&lt;T&gt;() -&gt; T { guard let dependency = dependencies.first(where: { $0.value is T })?.value as? T else { fatalError(\"Can't resolve \\(T.self)\") } return dependency }} Main access point to the container; List of available dependencies to be resolved and accessed; Once initial resolve is complete we have to update shared value.Now we can setup simple dependency container with injected service:protocol LocationService { /* start() */ }protocol JourneyService { /* start() */ }class MockLocation: LocationService { /* start() */ }class MockJourney: JourneyService { /* start() */ }let location = Dependency { MockLocation() } // Future injection of LocationServicelet journey = Dependency { MockJourney() } // Future injection of JourneyServicelet dependencies = Dependencies()dependencies.register(location)dependencies.register(journey)At this point we have stored only blocks to be resolved.Deferred call to build() will finish setup:dependencies.build() // ResolveAnd usage inside ViewModel:class ViewModel { let service: LocationService = Dependencies.shared.resolve() init() { service.start() // Service is MockLocation instance }}It’s time to start with wrapping access to Dependencies.shared via @propertyWrapper feature.Property WrapperProperty wrapper it’s a struct (class or enum) with defined wrappedValue property.We can wrap dependency container calls into property wrapper:@propertyWrapperstruct Injected&lt;Dependency&gt; { var dependency: Dependency! // Resolved dependency var wrappedValue: Dependency { mutating get { if dependency == nil { let copy: Dependency = Dependencies.shared.resolve() self.dependency = copy // Keep copy } return dependency } mutating set { dependency = newValue } }}So now we can apply property wrapper in this way:@Injected var service: LocationServiceUsing Swift DSL for containerAdding @_functionBuilder struct and convenience initializers into Dependencies class will make it more Swifty:class Dependencies { @_functionBuilder struct DependencyBuilder { static func buildBlock(_ dependency: Dependency) -&gt; Dependency { dependency } static func buildBlock(_ dependencies: Dependency...) -&gt; [Dependency] { dependencies } } convenience init(@DependencyBuilder _ dependencies: () -&gt; [Dependency]) { self.init() dependencies().forEach { register($0) } } convenience init(@DependencyBuilder _ dependency: () -&gt; Dependency) { self.init() register(dependency()) } /* Previous code */}Usage:let dependencies = Dependencies { Dependency { LocationImpl() } Dependency { JourneyImpl() } // ...}dependencies.build()Iterate over injected dependenciesIf we need to manipulate on set of injected dependencies we can make dependency containerconform to Sequence protocol:extension Dependencies: Sequence { func makeIterator() -&gt; AnyIterator&lt;Any&gt; { var iter = dependencies.makeIterator() return AnyIterator { iter.next()?.value } }}Now it’s easy to find all dependencies of given protocol and do what we want:protocol Resettable { func reset() }Dependencies.shared .compactMap { $0 as? Resettable } .forEach { $0.reset() }Full ExampleService protocolsprotocol LocationService { var location: AnyPublisher&lt;CLLocation, Never&gt; { get } func start()}protocol JourneyService { func start()}Location service implementationsimport Combineimport Foundationimport CoreLocationclass RealLocation: LocationService { var location: AnyPublisher&lt;CLLocation, Never&gt; init() { /* setup location service and connect publisher */ } func start() { debugPrint(\"Real Location service has been started\") }}class MockLocation: LocationService { private let timer = Timer.publish(every: 1, on: RunLoop.main, in: .default) // 1 private let subject = PassthroughSubject&lt;CLLocation, Never&gt;() // 2 private var cancellables = Set&lt;AnyCancellable&gt;() var location: AnyPublisher&lt;CLLocation, Never&gt; init() { location = subject.eraseToAnyPublisher() timer .map { _ in CLLocation( latitude: CLLocationDegrees.random(in: 50..&lt;55), longitude: CLLocationDegrees.random(in: 33..&lt;36) ) } .subscribe(subject) // 3 .store(in: &amp;cancellables) } func start() { timer .connect() // 4 .store(in: &amp;cancellables) debugPrint(\"Mock Location service has been started\") }} Create Timer publisher to send values to pipeline each second on main RunLoop; Private publisher to forward location into public; Connect subscriber (timer will not start at this point); Start timer.Journey service implementationsJust simple Journey service implementations for testing:class RealJourney: JourneyService { func start() { debugPrint(\"Real Journey service has been started!\") }}class MockJourney: JourneyService { func start() { debugPrint(\"Mock Journey service has been started!\") }}Building dependencieslet dependencies = Dependencies { Dependency { RealLocation() } // Register LocationService Dependency { RealJourney() } // Register JourneyService}// Resolve only when it's neededdependencies.build()UsageSimple Journey view model:class JourneyViewModel { @Injected private var location: LocationService @Injected private var journey: JourneyService private var cancellables = Set&lt;AnyCancellable&gt;() func start() { location.start() location.location .sink { debugPrint($0) } .store(in: &amp;cancellables) } func ride() { journey.start() }}Start receiving locations:let viewModel = JourneyViewModel()viewModel.start() // location is resolved with RealLocationWill output ‘Real Location service has been started’.Because injected property is resolved on the first access to it we can replace implementation by rebuilding dependencies container:Dependencies { Dependency { MockLocation() } Dependency { MockJourney() }}.build()// viewModel.location is still RealLocationviewModel.ride() // but journey is resolved with MockJourneyWill output ‘Mock Journey service has been started’.Links Based on this Similar article Property Wrappers Combine" }, { "title": "Setup Samba on Raspberry Pi and FMCB on PS2", "url": "/posts/raspberry-pi-ps2-fmcb-smb/", "categories": "", "tags": "retro, raspberry pi", "date": "2020-04-14 09:59:38 +0200", "snippet": "Running PS2 games over network from USB drive connected to Raspberry Pi Setup USB Flash Drive Setup Raspberry Pi Setup FMCBUSB StoragePut games you own into DVD directory. (Or into CD is it’s CD)Raspberry PiStatic IP AddressUse ifconfig to discover available network interfaces. Usually wlan0 is for wireless and eth0 for ethernet.Configure in /etc/dhcpcd.conf:For ethernet set IP address to 192.168.0.111:interface eth0static ip_address=192.168.0.111/24static routers=192.168.0.1static domain_name_servers=192.168.0.1 8.8.8.8 fd51:42f8:caae:d92e::1For wireless set IP address to 192.168.0.113:interface wlan0static ip_address=192.168.0.113/24static routers=192.168.0.1static domain_name_servers=192.168.0.1 8.8.8.8 fd51:42f8:caae:d92e::1Mount USBDiscover UUID:pi@raspberrypi:~ $ ls -l /dev/disk/by-uuid/total 0lrwxrwxrwx 1 root root 15 Jun 6 11:28 6341-C9E5 -&gt; ../../mmcblk0p1lrwxrwxrwx 1 root root 15 Jun 6 11:28 80571af6-21c9-48a0-9df5-cffb60cf79af -&gt; ../../mmcblk0p2lrwxrwxrwx 1 root root 10 Jun 7 11:46 D7A4-1519 -&gt; ../../sda1USB Stick Drive usually stands for sdaX so UUID is D7A4-1519 in example above.Mount point:pi@raspberrypi:~ $ mkdir /media/ps2pi@raspberrypi:~ $ sudo chown -R pi:pi /media/usbAuto-mount configuration:pi@raspberrypi:~ $ sudo vi /etc/fstabAdd new line and save:UUID=D7A4-1519 /media/ps2 vfat auto,nofail,noatime,users,rw,uid=pi,gid=pi 0 0Reload services to re parse /etc/fstab:pi@raspberrypi:~ $ sudo systemctl daemon-reloadAnd mount drive:pi@raspberrypi:~ $ mount /media/ps2If drive has been formatted into exFAT file system:pi@raspberrypi:~ $ sudo apt-get install exfat-fuse exfat-utilsAnd use exfat in place of vfat in /etc/fstab.SambaInstall Samba:pi@raspberrypi:~ $ sudo apt-get install samba samba-common-binConfiguration:pi@raspberrypi:~ $ sudo vi /etc/samba/smb.conf[ps2]comment = PS2path = /media/ps2browseable = yeswritable = yesonly guest = nocreate mask = 0777directory mask = 0777public = yesguest ok = yesRestart &amp; verify:pi@raspberrypi:~ $ sudo /etc/init.d/smbd restartOn Mac: Finder -&gt; Go -&gt; Connect to Server… -&gt; smb://192.168.0.113/ps2 -&gt; Connect as GuestFMCBOPL -&gt; Network setup:- PS2 -IP address type StaticIP address 192.168.0.112Mask 255.255.255.0Gateway 192.168.0.1DNS Server 192.168.0.1- SMB Server -Address type IPAddress 192.168.0.113 // Raspberry Pi IPPort 445Share ps2 // Raspberry Pi Samba Shared DirectoryUser guestDon’t forget to save configuration.Links How to mount a USB flash disk on the Raspberry Pi Tree Structue" }, { "title": "Disk Utility on macOS", "url": "/posts/diskutil-macos/", "categories": "Productivity", "tags": "macos", "date": "2019-12-09 19:18:02 +0100", "snippet": "Disk Utility in TerminalList available volumes:$ diskutil list[...]/dev/disk2 (internal, physical): #: TYPE NAME SIZE IDENTIFIER 0: FDisk_partition_scheme *31.3 GB disk2 1: Windows_FAT_32 NO NAME 31.3 GB disk2s1Format to specific file system:$ sudo diskutil eraseDisk FAT32 NO_NAME MBRFormat /dev/disk2Format to EXT3:# Install e2fsprogs$ brew install e2fsprogs# Unmount is important$ diskutil unmountDisk /dev/disk2# Format as EXT3$ sudo $(brew --prefix e2fsprogs)/sbin/mkfs.ext3 /dev/disk2" }, { "title": "Setup QEMU on macOS", "url": "/posts/qemu/", "categories": "", "tags": "macos", "date": "2019-12-05 15:38:25 +0100", "snippet": "QEMU on macOSInstall QEMU first (e.g. using Homebrew):$ brew install qemuLaunch script based on GCW Zero’s one (removed SDL and audio set to none).It should mount ./sdcard folder as /media/QEMU\\ VVFAT/.#!/bin/sh# Possible values: spice, pa, alsa, sdl, oss, none, wavexport QEMU_AUDIO_DRV=noneMACHINE=\"-M malta -m 256\"FIRMWARE=\"-kernel vmlinux -hda gcw0_system -hdb gcw0_data\"HARDWARE=\"-soundhw ac97 -rtc clock=vm\"NETWORK=\"-net nic,model=e1000 -net user\"STORAGE=\"-hdc fat:rw:sdcard\"qemu-system-mipsel $MACHINE $FIRMWARE $HARDWARE $NETWORK $SERIAL $STORAGESuccessful run and mount of shared folder: _________________________&lt; Welcome to OpenDingux ! &gt; ------------------------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || ||opendingux:/media/data/local/home # ls /media/QEMU\\ VVFAT/readme.txtQEMU window:Keys Arrow keys D-PAD Left Ctrl A Left Alt B SPACE Y Left Shift X Left Ctrl A TAB Left Backspace Right Escape Sel Enter Start Links Running GCW Zero applications with QEMU" }, { "title": "Using Grep to find files", "url": "/posts/using-grep/", "categories": "Productivity", "tags": "grep, vim", "date": "2019-11-20 19:28:27 +0100", "snippet": "The grep utility can be used to find files contains occurrences of the given pattern.$ man grepAdd colorsThere is an option to have matching text to be marked up. It’s nice to have it each time automatically.So it can be done by defining alias:alias grep='grep --color'Find filesTo find all files contains occurrences of the pattern ‘vi[m]?’ at the end of a line:$ grep -rEi 'vi[m]?$' .Where: -r — recursively -E — extended regular expression -i — case insensitive matchingTo print line numbers and show context surrounding match:$ grep -rEin -C1 'vim$' .--./vim-clipboard.md-12-./vim-clipboard.md:13:vim./vim-clipboard.md-14-:h registers----./vim-clipboard.md-35-bash./vim-clipboard.md:36:$ brew install vim./vim-clipboard.md-37---Where: -n — print line number -C — show contextTo print only filenames:$ grep -rl 'vim$' ../vim-clipboard.md Duplicates were removedWhere: -l — show only names of filesTo find all files not containing string:$ grep -rL 'vim' .Where: -L — show only names of files not containing stringMore useful options: -I — ignore binary filesCombine commandsIt’s possible to combine results and provide them into other tools using pipes.For example to execute rm command for each file in search results:$ grep -r 'string' . | xargs rm This will remove all files contained ‘string’ pattern in current directory. If file name contains spaces, here is a trick for macOS: grep -r 'string' . | tr '\\n' '\\0' | xargs -0 rmTo open result files in Vim:$ vim $(grep -rL 'pattern' .)Inside vim use :bn command to open next buffer and :bp command for previous.Summary Option Action -r Recursively search subdirectories -E Extended regular expression -i Case insensitive matching -w Match whole word -l Show only names of files -I Ignore binary files -n Print line number -C Show context -L Show only names of files not containing string " }, { "title": "Using system clipboard in Vim on macOS", "url": "/posts/vim-clipboard/", "categories": "Productivity", "tags": "vim, macos", "date": "2019-11-19 20:28:21 +0100", "snippet": "Using system clipboard in Vim on macOSWhen you do copy, cut and paste text in Vim it goes into Vim’s own buffer (register).Actually it has many registers, but we are’re interested only in primary (* or unnamed).More details on registers in Vim::h registersBut it’s possible to make it work with system clipboard too.Pre requirementsVim requires the +clipboard feature flag to be set during compile.Let’s check if Vim has this feature:$ vim --version | grep clipboard+clipboard +keymap +printer +vertsplit+emacs_tags -mouse_gpm -sun_workshop -xterm_clipboardBy default macOS Catalina ships without clipboard. But the good newswe can easy install Vim with the +clipboard feature from Homebrew for example:$ brew install vimSetupWe can set default register to unnamed clipboard with command:set clipboard=unnamedMore details on clipboard in Vim::h clipboardI use shared .vimrc configuration file across different machines,so first check if it’s supported by Vim:\" .vimrc\"\" Set default clipboard register to system's unnamed\"if has('clipboard') set clipboard=unnamedendifNow commands like y and d will put text into system clipboardas well as p command will take text from clipboard.Usage Command Action yw Copy word yy Copy line gg\"*yG Copy entire file y$ Copy till end of the line dw Cut word dd Cut line d$ Cut till end of the line P Paste before cursor p Paste after cursor " }, { "title": "CALayer Animations", "url": "/posts/calayer-animations/", "categories": "", "tags": "swift", "date": "2018-09-18 11:28:21 +0200", "snippet": "Create custom progress view using CALayer and CoreAnimation.Start with base class and protocols.Our base class should have progress property marked as @NSManaged to work with CoreAnimation.Also we need to redraw our layer on progress property update.To do it override needsDisplay(forKey:) method./// Base progress layer classclass BaseProgressLayer: CALayer { /// Progress key path constant string enum Keys: String { case progress = \"progress\" } /// To work with CoreAnimation this property should be marked ass @NSManaged /// which generates getter and setter @NSManaged var progress: CGFloat /// Redraw during progress value animation override class func needsDisplay(forKey key: String) -&gt; Bool { if key == Keys.progress.rawValue { return true } return super.needsDisplay(forKey: key) }}Progress view protocol is simple. Just read-only progress value and update method to set new progress value./// View with progress value and ability to updateprotocol ProgressableView { var progress: CGFloat { get } func update(_ progress: CGFloat, animated: Bool)}Now we can start with our progress view itself.It will be generic class with BaseProgressLayer as Layer and confirmed to ProgressableView protocol./// Progress view itself which supports animated progress value changesclass ProgressView&lt;Layer: BaseProgressLayer&gt;: UIView, ProgressableView { /// This view is backed by our Layer override class var layerClass: AnyClass { return Layer.self } /// Update content scale to window's one override func didMoveToWindow() { super.didMoveToWindow() if let window = window { progressLayer.contentsScale = window.screen.scale progressLayer.setNeedsDisplay() } } /// Just for easy access var progressLayer: Layer { return self.layer as! Layer } public var progress: CGFloat { return progressLayer.progress } public func update(_ progress: CGFloat, animated: Bool) { // Not implemented yet }}Set new progress value without animation is very straightforward.Remove progress animation, set new progress and set needs display.private func updateInstantly(_ progress: CGFloat) { progressLayer.removeAnimation(forKey: BaseProgressLayer.Keys.progress.rawValue) progressLayer.progress = progress progressLayer.setNeedsDisplay()}To make it animated we need to create new CABasicAnimation for our @NSManaged progress key.Also we need to keep new progress value after animation ended.private func updateAnimated(_ progress: CGFloat) { progressLayer.removeAnimation(forKey: BaseProgressLayer.Keys.progress.rawValue) let animation = CABasicAnimation(keyPath: BaseProgressLayer.Keys.progress.rawValue) let oldValue = progressLayer.presentation()?.progress ?? 0 progressLayer.progress = oldValue animation.fromValue = oldValue animation.toValue = progress animation.duration = CFTimeInterval(fabsf(Float(oldValue - progress))) animation.fillMode = kCAFillModeForwards animation.isRemovedOnCompletion = true animation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut) animation.delegate = self progressLayer.add(animation, forKey: BaseProgressLayer.Keys.progress.rawValue)}func animationDidStop(_ anim: CAAnimation, finished flag: Bool) { if let value = anim.value(forKey: \"toValue\") as? CGFloat { progressLayer.progress = value }}Now we can complete update method:public func update(_ progress: CGFloat, animated: Bool) { if animated { updateAnimated(progress) } else { updateInstantly(progress) }}We have flexible progress view which draws nothing!It’s time to make simple circle progress view.First of all we need to create new layer subclass to make our drawings of progress.We override draw(in:) function to draw our filled circles based on progress value./// Layer to style circle view progressclass CircleProgressLayer: BaseProgressLayer { @NSManaged var segmentsCount: Int @NSManaged var trackColor: UIColor @NSManaged var trackLineWidth: CGFloat @NSManaged var progressColor: UIColor @NSManaged var progressLineWidth: CGFloat override func draw(in ctx: CGContext) { ctx.clear(self.bounds) drawTrack(in: ctx) drawProgress(in: ctx) } private var step: CGFloat { return CGFloat.pi * 2 / CGFloat(segmentsCount * 2) } private var radius: CGFloat { return min(self.bounds.width, self.bounds.height) / 2 - max(trackLineWidth, progressLineWidth) / 2 } private var center: CGPoint { return CGPoint(x: self.bounds.midX, y: self.bounds.midY) } private func drawTrack(in ctx: CGContext) { ctx.setLineWidth(trackLineWidth) ctx.setStrokeColor(trackColor.cgColor) drawSegmentes(in: ctx, progress: 1.0) } private func drawProgress(in ctx: CGContext) { ctx.setLineWidth(progressLineWidth) ctx.setStrokeColor(progressColor.cgColor) drawSegmentes(in: ctx, progress: progress) } private func drawSegmentes(in ctx: CGContext, progress: CGFloat) { if segmentsCount &lt;= 1 { let circle = UIBezierPath( arcCenter: center, radius: radius, startAngle: -CGFloat.pi / 2, endAngle: (progress * CGFloat.pi * 2) - CGFloat.pi / 2, clockwise: true ) ctx.setLineCap(.round) ctx.addPath(circle.cgPath) ctx.strokePath() } else { let count = Int(CGFloat(segmentsCount) * progress) var current = -CGFloat.pi / 2 for _ in 0..&lt;count { let arc = UIBezierPath( arcCenter: center, radius: radius, startAngle: current, endAngle: current + step, clockwise: true ) ctx.setLineCap(.square) ctx.addPath(arc.cgPath) ctx.strokePath() current += step * 2 } } }}Appearance of the progress like track and progress colors can be set during view initialization.Our CircleProgressView is just ProgressView&lt;CircleProgressLayer&gt;.All extra code is only to set up appearance properties./// Circle progress view width custom optionsclass CircleProgressView: ProgressView&lt;CircleProgressLayer&gt; { struct Options { let segmentsCount: Int let trackColor: UIColor let trackLineWidth: CGFloat let progressColor: UIColor let progressLineWidth: CGFloat init(segmentsCount: Int = 1, trackColor: UIColor = UIColor(red: 0, green: 148/255.0, blue: 50/255.0, alpha: 1.0), trackLineWidth: CGFloat = 8, progressColor: UIColor = UIColor(red: 196/255.0, green: 229/255.0, blue: 56/255.0, alpha: 1.0), progressLineWidth: CGFloat = 6) { self.segmentsCount = segmentsCount self.trackColor = trackColor self.trackLineWidth = trackLineWidth self.progressColor = progressColor self.progressLineWidth = progressLineWidth } } var options: Options = Options() { didSet { applyOptions() } } convenience init(options: Options) { self.init() self.options = options applyOptions() } private func applyOptions() { progressLayer.segmentsCount = options.segmentsCount progressLayer.trackColor = options.trackColor progressLayer.trackLineWidth = options.trackLineWidth progressLayer.progressColor = options.progressColor progressLayer.progressLineWidth = options.progressLineWidth progressLayer.setNeedsDisplay() }}Full circle:Segmented one:The same with line progress view.Layer:/// Layer to style a line view progressclass LineProgressLayer: BaseProgressLayer { @NSManaged var segmentsCount: Int @NSManaged var lineWidth: CGFloat @NSManaged var spacing: CGFloat @NSManaged var trackColor: UIColor @NSManaged var progressColor: UIColor override func draw(in ctx: CGContext) { ctx.clear(self.bounds) drawTrack(in: ctx) drawProgress(in: ctx) } private var segmentWidth: CGFloat { return (self.bounds.width - CGFloat(segmentsCount - 1) * spacing) / CGFloat(segmentsCount) } private var centerY: CGFloat { return self.bounds.midY - lineWidth / 2 } private func drawTrack(in ctx: CGContext) { ctx.setFillColor(trackColor.cgColor) drawSegments(in: ctx, progress: 1.0) } private func drawProgress(in ctx: CGContext) { ctx.setFillColor(progressColor.cgColor) drawSegments(in: ctx, progress: progress) } private func drawSegments(in ctx: CGContext, progress: CGFloat) { if segmentsCount &lt;= 1 { let rect = UIBezierPath(roundedRect: CGRect( x: -lineWidth / 2, y: centerY, width: (bounds.width + lineWidth) * progress, height: lineWidth ), cornerRadius: lineWidth / 2) ctx.addPath(rect.cgPath) ctx.fillPath() } else { let count = Int(CGFloat(segmentsCount) * progress) for i in 0..&lt;count { ctx.fill(CGRect( x: CGFloat(i) * (segmentWidth + spacing), y: centerY, width: segmentWidth, height: lineWidth )) } } }}View:/// Line progress view with custom optionsclass LineProgressView: ProgressView&lt;LineProgressLayer&gt; { struct Options { let segmentsCount: Int let spacing: CGFloat let lineWidth: CGFloat let trackColor: UIColor let progressColor: UIColor init(segmentsCount: Int = 1, spacing: CGFloat = 4, lineWidth: CGFloat = 8, trackColor: UIColor = UIColor(red: 0, green: 98/255.0, blue: 102/255.0, alpha: 1.0), progressColor: UIColor = UIColor(red: 18/255.0, green: 203/255.0, blue: 196/255.0, alpha: 1.0)) { self.segmentsCount = segmentsCount self.spacing = spacing self.lineWidth = lineWidth self.trackColor = trackColor self.progressColor = progressColor } } var options: Options = Options() { didSet { applyOptions() } } convenience init(options: Options) { self.init() self.options = options applyOptions() } private func applyOptions() { progressLayer.segmentsCount = options.segmentsCount progressLayer.spacing = options.spacing progressLayer.lineWidth = options.lineWidth progressLayer.trackColor = options.trackColor progressLayer.progressColor = options.progressColor progressLayer.setNeedsDisplay() }}Single line:With segments:Source and Xcode playground:https://github.com/avdyushin/ProgressView" }, { "title": "Using Mixins in Swift", "url": "/posts/using-mixins-in-swift/", "categories": "", "tags": "swift", "date": "2017-03-19 20:28:21 +0100", "snippet": "Mixin — it is a protocol with default implementation of methods.Let’s say we have a registration screen with email input text field that needs to be validated to be sure it is correct email address.We can implement it in this way:class RegisterViewController: UIViewController { fileprivate func isValidEmail(_ email: String) -&gt; Bool { ... } @IBOutlet var emailTextField: UITextField! @IBAction func registerButtonDidPress() { guard isValidEmail(emailTextField.text!) else { print(\"Incorrect email provided\") return } ... }}We could put validation logic directly into view controller, but if we do that with everything then it will be too massive.One way to improve this is to create extension for String class which can be reused in future.extension String { var isValidEmail: Bool { ... }}Now validation logic is removed from view controller and can be reused.Another alternative solution to improve our code is to use mixins.protocol EmailValidatable { func isValidEmail(_ email: String) -&gt; Bool}Now we can create extension on protocol and add default implementation of isValidEmail method.extension EmailValidatable { func isValidEmail(_ email: String) -&gt; Bool { ... }}Once our view controller confirms to EmailValidatable protocol, it has access to isValidEmail method.class RegisterViewController: UIViewController, EmailValidatable { @IBOutlet var emailTextField: UITextField! @IBAction func registerButtonDidPress() { guard isValidEmail(emailTextField.text!) else { print(\"Incorrect email provided\") return } ... }}We just avoided extra helper objects and added new protocol :)Type-safe APILet’s create mixin Reusable:protocol Reusable: class { static var reusableIdentifier: String { get }}extension Reusable { static var reusableIdentifier: String { return String(describing: Self.self) }}Define new cell class which confirms to Reusable protocol:class MyCell: UITableViewCell, Reusable { func updateWithData(_ data: Objects) { ... }}Now we can extend UITableView to dequeue cells in easy way:extension UITableView { func dequeueReusableCell&lt;T&gt;(for indexPath: IndexPath) -&gt; T where T: UITableViewCell, T: Reusable { return self.dequeueReusableCell(withIdentifier: T.reusableIdentifier, for: indexPath) as! T }}Using new function we never reusable identifier as strings, so we can’t make typos.let cell: MyCell = tableView.dequeueReusableCell(for: indexPath)cell.updateWithData(someData)Links:https://alisoftware.github.io/swift/protocol/2015/11/08/mixins-over-inheritancehttps://github.com/AliSoftware/Reusable" }, { "title": "String pattern matching in Swift", "url": "/posts/swift-string-regex/", "categories": "", "tags": "swift", "date": "2016-07-18 14:06:56 +0200", "snippet": "Our goal is to use string pattern matching in easy-swifty way:// Credit card numberlet string = \"4916474932438684\"// Check if it's Visaif string =~ \"^4[0-9]{6,}$\" { /* */}Pattern matching with regular expression is supported by range function with .regularExpression options flag:if string.range(of: \"^4[0-9]{6,}$\", options: [.regularExpression]) { // string is matches /^4[0-9]{6,}$/}Let’s wrap this call into String’s extension helper function called matches:/// String extensionsextension String { /// Returns true if `String` matches regex `pattern`. /// - parameter pattern: pattern to search func matches(_ pattern: String) -&gt; Bool { range(of: pattern, options: [.regularExpression]) != nil }}Then we already can shortify matching call with our matches function:if string.matches(\"^4[0-9]{6,}$\") { /* */}The last step is to create infix operator for our function:/// String regex pattern matching operatorinfix operator =~/// Returns true if `string` matches regular expression `pattern`./// - parameter string: string to test/// - parameter pattern: pattern to matchfunc =~ (string: String, pattern: String) -&gt; Bool { string.matches(pattern)}// Usage:if \"cat\" =~ \"[cb]at\" { /* */}" }, { "title": "Extensions in Swift", "url": "/posts/swift-extensions/", "categories": "", "tags": "swift", "date": "2015-02-26 15:19:26 +0100", "snippet": "Extensions in Swift allow us to add methods to existing objects (class, struct, enum and protocol).They are similar to categories in Objective-C.Let’s extend UIColor class with custom convenience initialiser to create color with hex value:extension UIColor { /// Returns color with given hex integer value convenience init(hex: Int, alpha: CGFloat = 1.0) { let r = CGFloat((hex &amp; 0xff0000) &gt;&gt; 16) / 255.0 let g = CGFloat((hex &amp; 0x00ff00) &gt;&gt; 8) / 255.0 let b = CGFloat((hex &amp; 0x0000ff) &gt;&gt; 0) / 255.0 self.init(red: r, green: g, blue: b, alpha: alpha) }}Now we can create colors in this way:let color1 = UIColor(hex: 0x1abc9c, alpha: 0.5)let color2 = UIColor(hex: 0x112233)We can also add methods and read-only properties to instances of UIColor class:extension UIColor { /// Returns hex string color representation func toHexString(prefix: String = \"#\") -&gt; String { String(format:\"\\(prefix)%06x\", asInt) } /// Returns integer color representation var asInt: Int { var r: CGFloat = 0, g: CGFloat = 0, b: CGFloat = 0, a: CGFloat = 0 getRed(&amp;r, green: &amp;g, blue: &amp;b, alpha: &amp;a) return (Int)(r * 255) &lt;&lt; 16 | (Int)(g * 255) &lt;&lt; 8 | (Int)(b * 255) &lt;&lt; 0 }}New methods asInt and asHexString now available for any UIColor instance:let myRed = UIColor(hex: 0x991122) // r 0,6 g 0,067 b 0,067 a 1,0let intValue = myRed.asInt // 10031377let cssColor = myRed.toHexString() // \"#991122\"Static (or class) methods and read-only properties can be defined in extensions as well:extension UIColor { static var myRed: Color { UIColor(hex: 0xAA0000) }}Usage:let myColor = UIColor.myRedLinks Extensions My UIColor extensions" }, { "title": "Command, option and shift in Unicode", "url": "/posts/command-option-and-shift-symbols/", "categories": "", "tags": "macos", "date": "2014-03-25 13:58:29 +0100", "snippet": "Unicode macOS symbols list: ⌘ – &amp;#x2318; – &amp;#8984; – Command Key ⌥ – &amp;#x2325; – &amp;#8997; – Option Key ⇧ – &amp;#x21E7; – &amp;#8679; – Shift Key ⎋ – &amp;#x238B; – &amp;#9099; – ESC Key ⇪ – &amp;#x21ea; – &amp;#8682; – Capslock ⏎ – &amp;#x23ce; – &amp;#9166; – Return ⌫ – &amp;#x232b; – &amp;#9003; – DeleteTo be able use this kind of notes: ⌘ + ⇧ + ⏎" }, { "title": "Как поменять память в MacBook Pro", "url": "/posts/macbookpro-memory-upgrade/", "categories": "", "tags": "macos", "date": "2013-02-19 10:15:02 +0100", "snippet": "Сегодня наконец-то поменял память в своем MacBook Pro. Расскажу немного как это сделать самостоятельно.Для начала разберем наш ноутбук. Выключаем ноутбук. Отсоединяем все кабели. Ничего не должно мешать нашей работе.Подложим что-то мягкое на стол, чтобы не поцарапать ноутбук.Переворачиваем ноутбук и выкручиваем все 10 винтов на нижней крышке.Аккуратно подцепляем крышку и снимаем ее.Обратите внимание на то, что три винта длиннее всех остальных, это надо учесть при закручивании их обратно.Так же следует заметить, что часть винтов закручивается под углом, а не перпендикулярно поверхности ноутбука.Для работы я использую крестовую отвертку и пару пластиковых приспособлений из набора для разбора гаджетов.Такой набор я купил в китайском магазине.Снимаем крышку и откладываем ее в сторону.Снятие модуля памятиЧтобы снять модуль памяти необходимо нажать на защелки по бокам модуля памяти в наружную сторону.Модуль памяти должен выдвинуться под углом. Вынимаем модуль. Так же вынимаем второй модуль.Установка и сборкаУстановка модулей памяти аналогична снятию. Сначала устанавливаем нижнюю планку, затем верхнюю.Осталось только только поставить заднюю крышку и закрутить винты. И можно радоваться новому объему памяти.ЗаключениеДолго выбирал какую память поставить на свой MacBook Pro 13-inch, Mid 2009и остановился на Kingston KVR1066D3S7/4G, хотя сам Kingston рекомендует серию KTAдля ноутбуков Apple. Полет нормальный, проблем не обнаружено.Какая именно память подходит на ваш ноутбук и как его разбирать, можно ознакомиться на сайте Apple:MacBook Pro: извлечение или установка модуля памяти" } ]
